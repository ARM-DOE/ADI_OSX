################################################################################
# RCS INFORMATION: 
#   $Author: younkin $ 
#   $Locker:  $ 
#   $Revision: 1.176 $ 
#   $Date: 2008-05-30 17:44:10 $ 
#   $Name: not supported by cvs2svn $ 
#   $State: Exp $ 
#
# PURPOSE:
#   To provide standard definitions across all components of the system.
#
# DESCRIPTION:
#   <Provide a brief description of the definitions in this make include file>
#
#------------------------------------------------------------------------
#
# Interesting info taken from "GNU Make" by Stallman and McGrath.
#
#   These are the Automatic variables used in gnumake (p112):
#
#   $@ - file name of the target of the rule
#   $% - target member name if archive (eg $% = bar.o given foo.a(bar.o))
#   $< - name of the first dependency
#   $^ - names of all dependencies (with spaces)
#   $? - names of all dependencies newer than the target (with spaces)
#   $* - stem of target in implicit rule match (eg $* = x given a.x.b and a.%.b)
#
#   Some useful variables with built-in values (p107-108, unuseful excluded)
#
#   CPP = $(CC) -E    (C preprocessor -- we may use this)
#   CC = cc           (C compiler -- we will use this)
#   FC = f77          (Fortran compiler -- we may use this)
#   CXX = g++         (C++ compiler -- we will use this)
#   AR = ar           (archive maintaining program -- we will use this)
#   ARFLAGS = rv      (flags for ar -- we will use/suppliment this)
#   CO = co           (Extracting files from RCS -- we will use this)
#   RM = rm -f        (Command to remove a file -- we will use this I guess)
#
# LIMITATIONS:
################################################################################


################################################################################
# Some default values for some generic, commonly used variables.
################################################################################
RM_RECURSE        = $(RM)r
BUILT_MESG        = echo "BUILT:   $@"
NOT_BUILT_MESG    = echo "FAILED:  $@"
MF_OLD            = Dependencyfile Makefile.deps .Makedefs.gs

RELEASE_TARGET   := default_target
DEFAULT_TARGET   := default_target

################################################################################
# Variables to determine what source code will be built from the given directory
################################################################################
ALL_SRCS         := $(wildcard *)
CPP_SRCS         := $(filter %.cpp, $(ALL_SRCS))
CC_SRCS          := $(filter %.cc, $(ALL_SRCS))
F90_SRCS         := $(filter %.f90, $(ALL_SRCS))
F_SRCS           := $(filter %.f, $(ALL_SRCS))
PERL_SRCS        := $(filter %.perl, $(ALL_SRCS))
PL_SRCS          := $(filter %.pl, $(ALL_SRCS))
PM_SRCS          := $(filter %.pm, $(ALL_SRCS))

ifneq ($(CPP_SRCS),)
  CXX_SFX         = cpp
endif
ifneq ($(CC_SRCS),)
  ifeq ($(CXX_SFX),)
    CXX_SFX       = cc
  else
    ERR_MESG     += echo "    Cannot make cpp and cc files in same directory" ;
  endif
endif

ifneq ($(F90_SRCS),)
  FOR_SFX        := f90
endif
ifneq ($(F_SRCS),)
  ifeq ($(FOR_SFX),)
    FOR_SFX      := f
  else
    ERR_MESG     += echo "    Cannot make f90 and f files in same directory" ;
  endif
endif

ifneq ($(PERL_SRCS),)
  PERL_SFX        := perl
  PM_SFX          := ${PERL_SFX}
endif
ifneq ($(join $(PL_SRCS),$(PM_SRCS)),)
  ifeq ($(PERL_SFX),)
    PERL_SFX      := pl
    PM_SFX        := pm
  else
    ERR_MESG     += echo "    Cannot make perl and pl files in same directory" ;
  endif
endif

################################################################################
# Variables used to help find paths
################################################################################
ONLY_FIRST        = sed -n '1p'
ALL_BUT_FIRST     = sed -n '2,$$p'
AWK_CMD           = awk '{for (i=2; i<=NF; ++i) print $$i}'
FIND_IT          := /usr/bin/env

# The FIND_IT technique doesn't work if -w (perl) or -f (csh) are used
#PERL_PATH        := $(FIND_IT) perl
#PHP_PATH         := $(FIND_IT) php
#CSH_PATH         := $(FIND_IT) csh
#SH_PATH          := $(FIND_IT) sh
#BASH_PATH        := $(FIND_IT) csh
#KSH_PATH         := $(FIND_IT) ksh

CSH_PATH         := /bin/csh
SH_PATH          := /bin/sh
BASH_PATH        := /bin/bash
KSH_PATH         := /bin/ksh

ifdef $(IAM_UC)_FOR_WINDOWS
  PERL_PATH      := perl
else
  PERL_PATH      := $(GS_PERL_PATH)
endif

ifeq ($(PERL_PATH),)
  PERL_PATH      := $(shell which perl)
endif


################################################################################
# Some default values that may be overridden
################################################################################
ifeq ($(MAKE_TYPE),exe)
  PERMISSIONS     = 0755
else
  ifeq ($(MAKE_TYPE),test)
    PERMISSIONS   = 0755
  else
    PERMISSIONS   = 0644
  endif
endif

################################################################################
# List of component specific directories that make will use to do the builds.
# These all key off of the COMP_HOME variable that must be defined in a
# component make template (eg Makedefs.vap or Makedefs.ingest).  The values
# defined below can be overridden in the component make template but that is not
# encouraged.
################################################################################
INC_DIR           = $(COMP_HOME)/include
LIB_DIR           = $(COMP_HOME)/lib$(BITS64_DIR)
CONF_DIR          = $(COMP_HOME)/conf
SRC_DIR           = $(COMP_HOME)/src
AUTODOC_DIR       = $(COMP_HOME)/www/Root/$(COMP_NAME)/autodoc

BYTECODE_DIR      = $(COMP_HOME)/bytecode
BIN_DIR           = $(COMP_HOME)/bin
WEB_BYTECODE_DIR  = $(COMP_HOME)/www/Root/$(COMP_NAME)/bytecode
CGI_STRATEGY      = $(GS_CGI_STRATEGY)
ifeq ($(CGI_STRATEGY),exec_cgi)
  WEB_BIN_DIR     = $(COMP_HOME)/www/Root/$(COMP_NAME)/cgi-bin
else
  WEB_BIN_DIR     = $(COMP_HOME)/www/cgi-bin/$(COMP_NAME)
endif

################################################################################
# Some default values for the supported languages
################################################################################

# The C language
C_SFX            := c
C_ARFLAGS        := $(ARFLAGS)
C_SRCS           := $(filter %.$(C_SFX), $(ALL_SRCS))

# The C++ language
CXX_ARFLAGS      := $(ARFLAGS)
CXX_SRCS         := $(filter %.$(CXX_SFX), $(ALL_SRCS))

# The Fortran language
FOR_ARFLAGS      := $(ARFLAGS)
FOR_SRCS         := $(filter %.$(FOR_SFX), $(ALL_SRCS))

# The Perl language
#PERL_SFX         := perl
PERL_SRCS        := $(filter %.$(PERL_SFX), $(ALL_SRCS))
PM_SRCS          := $(filter %.$(PM_SFX), $(ALL_SRCS))
PP_GREP           = grep "^ *package" $(PERL_SRCS)
PP_AWK1           = awk -F\# '{ print $$1 }' | sed -e "s/ *;/;/g"
PP_AWK2           = awk '{ print $$NF}'
PP_SED            = sed -e "s|::|/|g" -e "s|;||g"

# SWIG
SWIG_SFX         := i
SWIG_SRCS        := $(filter %.$(SWIG_SFX), $(ALL_SRCS))
ifneq ($(SWIG_SRCS),)
  SWIG_COMPILER_FLAGS := $(shell perl -MExtUtils::Embed -e ccopts)
  SWIG_SO_DIR          = $(LIB_DIR)/auto
  SWIG_NAMES           = $(patsubst %.$(SWIG_SFX),%,$(SWIG_SRCS))
  SWIG_CMD     = grep '^ *% *module' $(SWIG_SRCS)|awk '{print $$2}'|sed 's/"//g'
  SWIG_MODS   := $(shell $(SWIG_CMD))
  SWIG_PKGS    = $(subst ::,/,$(SWIG_MODS))
  SWIG_PM_REL  = $(foreach thing, $(SWIG_PKGS), $(dir $(thing)))
  SWIG_SO_REL  = $(addsuffix /, $(SWIG_PKGS))
  SWIG_SO_NS= $(join $(SWIG_SO_REL),$(patsubst %.$(SWIG_SFX),%.so,$(SWIG_SRCS)))
  SWIG_PM_NS= $(join $(SWIG_PM_REL),$(patsubst %.$(SWIG_SFX),%.pm,$(SWIG_SRCS)))
  SWIG_PMS    = $(addprefix $(LIB_DIR)/,    $(SWIG_PM_NS))
  SWIG_SOS    = $(addprefix $(SWIG_SO_DIR)/, $(SWIG_SO_NS))
  SWIG_WRAPC  = $(patsubst %.pm,%_wrap.c,$(SWIG_PMS))
  SWIG_WRAPO  = $(patsubst %.c,%.o,$(SWIG_WRAPC))
  SWIG_OUT    = $(SWIG_PMS) $(SWIG_WRAPC) $(SWIG_WRAPO) $(SWIG_SOS)
  SWIG_TARGET = $(SWIG_OUT)
  SWIG_WRAPS = $(subst .pm,_wrap.c,$(SWIG_PMS)) $(subst .pm,_wrap.o,$(SWIG_PMS))
  SWIG_PM_TGT = $(SWIG_PMS)
  SWIG_SO_TGT = $(SWIG_SOS)
  SWIG_I_FILE   = $(patsubst %.pm, %.$(SWIG_SFX), $(@F))
  SWIG_SO_WRAPO = $(subst /$(@F),_wrap.o,$(subst /auto,,$@))
  SWIG_PM_WRAPC = $(subst .pm,_wrap.c, $@)
endif

# The Python language
PYTHON_SFX       := py
PYTHON_SRCS      := $(subst setup.py,,$(filter %.$(PYTHON_SFX), $(ALL_SRCS)))

# The PHP language
PHP_SFX          := php
PHP_SRCS         := $(filter %.$(PHP_SFX), $(ALL_SRCS))

# The CSH script language
CSH_SFX          := csh
CSH_SRCS         := $(filter %.$(CSH_SFX), $(ALL_SRCS))

# The SH script language
SH_SFX           := sh
SH_SRCS          := $(filter %.$(SH_SFX), $(ALL_SRCS))

# The BASH script language
BASH_SFX         := bash
BASH_SRCS        := $(filter %.$(BASH_SFX), $(ALL_SRCS))

# The KSH script language
KSH_SFX          := ksh
KSH_SRCS         := $(filter %.$(KSH_SFX), $(ALL_SRCS))

# The Java language
JAVA_SFX          := java
JAVA_ARCHIVER     := jar
JAVA_PKG_ARFLAGS  := cvf 
JAVA_COMP_ARFLAGS := uvf
JAVA_SRCS         := $(filter %.$(JAVA_SFX), $(ALL_SRCS))
JAVA_PKG_PREFIX    = $(COMP_NAME)
JAVA_COMP_JAR      = $(BYTECODE_DIR)/$(COMP_NAME).jar

# The IDL language
IDL_SFX           := pro
IDL_SRCS          := $(filter %.$(IDL_SFX), $(ALL_SRCS))

# The Matlab language
MATLAB_SFX        := m
MATLAB_SRCS       := $(filter %.$(MATLAB_SFX), $(ALL_SRCS))

# Web Content stuff
ifeq ($(MAKE_TYPE),content)
  WEB_SFXS :=$(strip $(subst $(COMMA),$(SPACE),$(GS_WEB_CONTENT_EXTENSIONS)))
  WEB_SRCS :=$(strip $(foreach sfx,$(WEB_SFXS),$(filter %.$(sfx), $(ALL_SRCS))))
endif

LANGS               := $(C_SFX) $(CXX_SFX) $(FOR_SFX) $(PERL_SFX) $(PHP_SFX) \
                       $(PYTHON_SFX) $(JAVA_SFX) $(IDL_SFX) \
                       $(CSH_SFX) $(BASH_SFX) $(SH_SFX) $(KSH_SFX) \
                       $(WEB_SFXS) $(MATLAB_SFX) $(OTHER_SFX)

ifeq ($(BITS64),true)
  ifeq ($(ARCH_NAME),i86pc)
    BITS64_DIR       = /64
    BITS64_FLAGS     = -m64
  else
    ifeq ($(OS_NAME),SunOS)
      BITS64_DIR     = /sparcv9
      BITS64_FLAGS   = -xtarget=ultra -xarch=v9 -xcode=pic32
    else
      ifeq ($(OS_NAME),Linux)
        BITS64_DIR   = 64
        BITS64_FLAGS = -m64
#        BITS64       = false
      endif
    endif
  endif
else
  BITS64_FLAGS       =
  BITS64_DIR         =
endif

################################################################################
# Derive the rest of the stuff for any C source code
#
# If we have more than one word in value for the OUT variable, then we're
# building a set of executables that correspond with the source code names.
# That is, gnu make uses the REG_SRCS variable to produce a corresponding list
# of binaries and that list becomes the value of OUT.  This is done when the
# -test option of genmake is used to generate a Makefile.  In this case, the
# object files and object dependencies need to be set differently.  The OBJ_DEPS
# variable is necessary for Make to find a target when building the "multiple
# word OUT."  If just OBJS is used as both the dependency and in the rule (the
# logical assumption) this blows up.  I have absolutely no idea why this is the
# case.  If OUT is just a single word, then using OBJS is fine for both the
# dependency and in the rule.
################################################################################
ifeq ($(MATLAB_SRCS),)
  REG_SRCS         = $(C_SRCS) $(CXX_SRCS) $(FOR_SRCS)
else
  OBJ_DIR          = obj$(BITS64_DIR)
endif

ifneq ($(strip $(REG_SRCS)),)
  OBJ_DIR          = obj$(BITS64_DIR)

  ifeq ($(MAKE_TYPE),exe)
    OUT_DIR        = $(BIN_DIR)
    ifeq ($(OUT_NAME),)
      REG_OUT      =  $(patsubst %.$(C_SFX), $(OUT_DIR)/%, $(C_SRCS))
      REG_TARGET   = $(REG_OUT)
    else
      REG_OUT      = $(OUT_NAME)
      REG_TARGET   = $(OUT_DIR)/$(REG_OUT)
    endif
  endif

  ifeq ($(MAKE_TYPE),lib)
    OUT_DIR        = $(LIB_DIR)
    REG_OUT        = lib$(OUT_NAME).a
    REG_TARGET     = $(OUT_DIR)/$(REG_OUT)

    ifdef SO
      SO_OUT       = lib$(OUT_NAME).so
      SO_TARGET   += $(OUT_DIR)/$(SO_OUT)
    endif
  endif

  ifeq ($(MAKE_TYPE),test)
    OUT_DIR        =  .
    REG_OUT        =  $(patsubst %.$(C_SFX), $(OUT_DIR)/%, $(C_SRCS))
    REG_OUT       += $(patsubst %.$(CXX_SFX), $(OUT_DIR)/%, $(CXX_SRCS))
    REG_OUT       += $(patsubst %.$(FOR_SFX), $(OUT_DIR)/%, $(FOR_SRCS))
    REG_TARGET     = $(REG_OUT)
  endif

  OBJS             =  $(patsubst %.$(C_SFX), $(OBJ_DIR)/%.o, $(C_SRCS))
  OBJS            += $(patsubst %.$(CXX_SFX), $(OBJ_DIR)/%.o, $(CXX_SRCS))
  OBJS            += $(patsubst %.$(FOR_SFX), $(OBJ_DIR)/%.o, $(FOR_SRCS))

  ifneq ($(MAKE_TYPE),test)  # In this case just use OBJS for both
    OBJ_DEPS       = $(OBJS)
    OBJ_FILES      = $(OBJS)
  else                         # However, here we need some special treatment
    OBJ_FILES      =  $(patsubst %.$(C_SFX), $(OBJ_DIR)/%.o, $(C_SRCS))
    OBJ_FILES     += $(patsubst %.$(CXX_SFX), $(OBJ_DIR)/%.o, $(CXX_SRCS))
    OBJ_FILES     += $(patsubst %.$(FOR_SFX), $(OBJ_DIR)/%.o, $(FOR_SRCS))
    OBJ_DEPS       =  $(patsubst %.$(C_SFX), $(OBJ_DIR)/%.o, $(C_SRCS))
    OBJ_DEPS      += $(patsubst %.$(CXX_SFX), $(OBJ_DIR)/%.o, $(CXX_SRCS))
    OBJ_DEPS      += $(patsubst %.$(FOR_SFX), $(OBJ_DIR)/%.o, $(FOR_SRCS))
  endif

endif


################################################################################
# Derive the rest of the stuff for any PYTHON source code
################################################################################
ifneq ($(PYTHON_SRCS),)
  ifeq ($(MAKE_TYPE),exe)
    ifdef WEB
      PYTHON_OUT_DIR    = $(WEB_BIN_DIR)
    else
      PYTHON_OUT_DIR    = $(BIN_DIR)
    endif
    PYTHON_OUT        = $(patsubst %.$(PYTHON_SFX), $(PYTHON_OUT_DIR)/%, $(PYTHON_SRCS))
  endif

  ifeq ($(MAKE_TYPE),lib)
    PYTHON_PKG_DIR = $(COMP_HOME)/src/$(PKG_NAME)
    PYTHON_REL_DIR = $(notdir $(subst $(PYTHON_PKG_DIR),,$(PWD)))
    PYTHON_OUT_DIR = $(LIB_DIR)
    ifeq ($(PYTHON_REL_DIR),)
      PYTHON_OUT_DIR = $(LIB_DIR)
    else
      PYTHON_OUT_DIR = $(LIB_DIR)/$(PYTHON_REL_DIR)
    endif
    PYTHON_INIT    = $(PYTHON_OUT_DIR)/__init__.py
    PYTHON_OUT     = $(patsubst %, $(PYTHON_OUT_DIR)/%, $(PYTHON_SRCS))
    PYTHON_OUT    += $(PYTHON_INIT)
  endif

  ifeq ($(MAKE_TYPE),test)
    PYTHON_OUT_DIR = .
    PYTHON_OUT     = $(patsubst %.$(PYTHON_SFX), %, $(PYTHON_SRCS))
  endif

  PYTHON_PYC       = $(addsuffix c,$(PYTHON_OUT)) $(addsuffix c,$(PYTHON_SRCS))
  PYTHON_PYO       = $(addsuffix o,$(PYTHON_OUT)) $(addsuffix o,$(PYTHON_SRCS))
  PYTHON_EXTRAS    = $(PYTHON_PYC) $(PYTHON_PYO)

  PYTHON_MODULES   = $(patsubst %.$(PYTHON_SFX), %, $(PYTHON_SRCS))
  PYTHON_TARGET    = $(PYTHON_OUT)
endif


################################################################################
# Derive the rest of the stuff for any PERL source code
################################################################################
ifneq ($(PERL_SRCS),)
  ifeq ($(MAKE_TYPE),exe)
    ifdef WEB
      PERL_OUT_DIR   = $(WEB_BIN_DIR)
    else
      PERL_OUT_DIR   = $(BIN_DIR)
    endif
    PERL_OUT       = $(patsubst %.$(PERL_SFX), $(PERL_OUT_DIR)/%, $(PERL_SRCS))
#PERL_OUT       = $(join $(PL_OUT),$(patsubst %.$(PM_SFX), $(LIB_DIR)/%.pm, $(PM_SRCS)))
  endif

  ifeq ($(MAKE_TYPE),lib)
    PERL_PKGS      = $(shell $(PP_GREP) | $(PP_AWK1) | $(PP_AWK2) | $(PP_SED))
    PERL_OUT_DIR   = $(LIB_DIR)
    PERL_OUT       = $(patsubst %, $(PERL_OUT_DIR)/%.pm, $(PERL_PKGS))
  endif

  ifeq ($(MAKE_TYPE),test)
    PERL_OUT_DIR   = .
    PERL_OUT       = $(patsubst %.$(PERL_SFX), %, $(PERL_SRCS))
  endif

  PERL_TARGET      = $(PERL_OUT)
endif


################################################################################
# Derive the rest of the stuff for any CSH source code
################################################################################
ifneq ($(CSH_SRCS),)
  ifeq ($(MAKE_TYPE),exe)
    ifdef WEB
      CSH_OUT_DIR    = $(WEB_BIN_DIR)
    else
      CSH_OUT_DIR    = $(BIN_DIR)
    endif
    CSH_OUT        = $(patsubst %.$(CSH_SFX), $(CSH_OUT_DIR)/%, $(CSH_SRCS))
  endif

  ifeq ($(MAKE_TYPE),lib)
    CSH_OUT_DIR    = $(LIB_DIR)
    CSH_OUT        = $(patsubst %.$(CSH_SFX), $(CSH_OUT_DIR)/%, $(CSH_SRCS))
  endif

  ifeq ($(MAKE_TYPE),test)
    CSH_OUT_DIR    = .
    CSH_OUT        = $(patsubst %.$(CSH_SFX), %, $(CSH_SRCS))
  endif

  CSH_TARGET       = $(CSH_OUT)
endif


################################################################################
# Derive the rest of the stuff for any SH source code
################################################################################
ifneq ($(SH_SRCS),)
  ifeq ($(MAKE_TYPE),exe)
    ifdef WEB
      SH_OUT_DIR     = $(WEB_BIN_DIR)
    else
      SH_OUT_DIR     = $(BIN_DIR)
    endif
    SH_OUT         = $(patsubst %.$(SH_SFX), $(SH_OUT_DIR)/%, $(SH_SRCS))
  endif

  ifeq ($(MAKE_TYPE),lib)
    SH_OUT_DIR     = $(LIB_DIR)
    SH_OUT         = $(patsubst %.$(SH_SFX), $(SH_OUT_DIR)/%.shrc, $(SH_SRCS))
  endif

  ifeq ($(MAKE_TYPE),test)
    SH_OUT_DIR     = .
    SH_OUT         = $(patsubst %.$(SH_SFX), %, $(SH_SRCS))
  endif

  SH_TARGET        = $(SH_OUT)
endif


################################################################################
# Derive the rest of the stuff for any BASH source code
################################################################################
ifneq ($(BASH_SRCS),)
  ifeq ($(MAKE_TYPE),exe)
    ifdef WEB
      BASH_OUT_DIR   = $(WEB_BIN_DIR)
    else
      BASH_OUT_DIR   = $(BIN_DIR)
    endif
    BASH_OUT       = $(patsubst %.$(BASH_SFX), $(BASH_OUT_DIR)/%, $(BASH_SRCS))
  endif

  ifeq ($(MAKE_TYPE),lib)
    BASH_OUT_DIR = $(LIB_DIR)
    BASH_OUT   = $(patsubst %.$(BASH_SFX), $(BASH_OUT_DIR)/%.shrc, $(BASH_SRCS))
  endif

  ifeq ($(MAKE_TYPE),test)
    BASH_OUT_DIR   = .
    BASH_OUT       = $(patsubst %.$(BASH_SFX), %, $(BASH_SRCS))
  endif

  BASH_TARGET        = $(BASH_OUT)
endif


################################################################################
# Derive the rest of the stuff for any KSH source code
################################################################################
ifneq ($(KSH_SRCS),)
  ifeq ($(MAKE_TYPE),exe)
    ifdef WEB
      KSH_OUT_DIR    = $(WEB_BIN_DIR)
    else
      KSH_OUT_DIR    = $(BIN_DIR)
    endif
    KSH_OUT        = $(patsubst %.$(KSH_SFX), $(KSH_OUT_DIR)/%, $(KSH_SRCS))
  endif

  ifeq ($(MAKE_TYPE),lib)
    KSH_OUT_DIR    = $(LIB_DIR)
    KSH_OUT        = $(patsubst %.$(KSH_SFX), $(KSH_OUT_DIR)/%, $(KSH_SRCS))
  endif

  ifeq ($(MAKE_TYPE),test)
    KSH_OUT_DIR    = .
    KSH_OUT        = $(patsubst %.$(KSH_SFX), %, $(KSH_SRCS))
  endif

  KSH_TARGET       = $(KSH_OUT)
endif


################################################################################
# Derive the rest of the stuff for any Java source code
################################################################################
ifneq ($(JAVA_SRCS),)
  JRO_SFX         := $(GS_JAVA_REMOTE_OBJECT_SUFFIX)
  JIMP_GREP        = grep implements $(JAVA_SRCS) | grep class | grep $(JRO_SFX)
  JIMP_AWK         = awk -F: '{ print $$1 }'
  JIMP_CMD         = $(JIMP_GREP) | $(JIMP_AWK)
  JIMP_OUTPUT      = $(shell $(JIMP_CMD))

  ifeq ($(MAKE_TYPE),test)
    JAVA_IMPLS    := $(patsubst %.$(JAVA_SFX),%,$(JIMP_OUTPUT))
    JAVA_OUT_DIR   = obj
    JAVA_OUT       = $(patsubst %.$(JAVA_SFX),%.class,$(JAVA_SRCS))
    JAVA_TARGET    = $(JAVA_OUT)
  else
    JP_NAME        = $(JAVA_PKG_PREFIX).$(patsubst %.jar,%,$(JAVA_OUT))
    JAVA_IMPLS    := $(patsubst %.$(JAVA_SFX),$(JP_NAME).%,$(JIMP_OUTPUT))
    JAVA_PKG_PATH  = $(subst .,/,$(JP_NAME))
    JAVA_OUT_DIR   = $(BYTECODE_DIR)/$(JAVA_PKG_PATH)
    JAVA_OUT       = $(OUT_NAME).jar
  endif

  ifdef WEB
    JAVA_WEB_OUT_DIR = $(WEB_BYTECODE_DIR)/$(JAVA_PKG_PATH)
    JAVA_TARGET      = $(WEB_BYTECODE_DIR)/$(JAVA_OUT)
  else
    JAVA_TARGET      = $(BYTECODE_DIR)/$(JAVA_OUT)
  endif

  JAVA_COMPILE_DIR   = $(patsubst %/$(JAVA_PKG_PATH), %, $(JAVA_OUT_DIR))
  JAVA_PKG_JARS     := $(shell ls $(BYTECODE_DIR)/*.jar $(STD_ERR))

  JAVA_OBJS     = $(patsubst %.$(JAVA_SFX),$(JAVA_OUT_DIR)/%.class,$(JAVA_SRCS))
  JAVA_JAR_OBJS = $(patsubst $(BYTECODE_DIR)/%,%,$(JAVA_OBJS))

  ifneq ($(JAVA_IMPLS),)
    RMIC_CMD         = rmic -d $(JAVA_COMPILE_DIR) $(JAVA_IMPLS)
  endif
endif

################################################################################
# Derive the rest of the stuff for any IDL source code
################################################################################
ifneq ($(IDL_SRCS),)
  ifeq ($(MAKE_TYPE),lib)
    IDL_OUTDIR = $(LIB_DIR)/IDL
    IDL_OUTEXT = pro
  else
    IDL_OUTDIR = $(BYTECODE_DIR)
    IDL_OUTEXT = sav
  endif
  ifneq ($(OUT_NAME),)
    IDL_OUT         = $(IDL_OUTDIR)/$(OUT_NAME).$(IDL_OUTEXT)
  else
    IDL_OUT         = $(patsubst %.$(IDL_SFX),$(IDL_OUTDIR)/%.$(IDL_OUTEXT),$(IDL_SRCS))
  endif
  IDL_TARGET        = $(IDL_OUT)
  IDL_RESOLVE       = resolve_routine, \'$*\' \& resolve_all
  IDL_SAVE          = save, file=\'$@\', $(IDL_EMBED), /routines, variables=0
  IDL_MAKE_STR      = $(IDL_RESOLVE) \& $(IDL_SAVE) \& exit
endif

################################################################################
# Derive the rest of the stuff for any matlab source code
################################################################################
MEX_GREP           :=  [ ]*mexFunction[ ]*(
ifneq ($(MATLAB_SRCS),)
  MCC_FLAGS         = $(AUX_MATLAB_AFLAGS) $(AUX_MATLAB_IFLAGS) -I $(OBJ_DIR)
  ifneq ($(C_SRCS),)
    MEX_SRCS        = $(C_SRCS)
    MEX_OBJS        = $(patsubst %.$(C_SFX), $(OBJ_DIR)/%.mexsol, $(MEX_SRCS))
  endif
  MATLAB_OUT_DIR    = $(BIN_DIR)
  MATLAB_OUT        = $(OUT_NAME)
  MATLAB_TARGET     = $(MATLAB_OUT_DIR)/$(MATLAB_OUT)
  MATLAB_BYPRODUCTS = $(shell ls $(MATLAB_TARGET)_* $(STD_ERR)) $(MATLAB_TARGET).ctf $(MATLAB_OUT_DIR)/mccExcludedFiles.log
else
  DO_MEX           := $(shell grep -l ' $(MEX_GREP)' *.$(C_SFX) $(STD_ERR))
  ifneq ($(DO_MEX),)
    MEX_SRCS        = $(C_SRCS)
    MATLAB_OUT_DIR  = $(LIB_DIR)
    MATLAB_OUT      = $(OUT_NAME).mexsol
    MATLAB_TARGET   = $(MATLAB_OUT_DIR)/$(MATLAB_OUT)
    REG_TARGET      =
  endif
endif

################################################################################
# Derive the rest of the stuff for any WEB source code
#
# Where content (eg web material) will go by default (can be overridden)
################################################################################
WEB_OUT_ROOT    = $(COMP_HOME)/www/Root/$(COMP_NAME)

ifneq ($(WC_REL_DIR),)
  WEB_OUT_DIR   = $(WEB_OUT_ROOT)/$(WC_REL_DIR)
else
  WEB_OUT_DIR   = $(WEB_OUT_ROOT)
endif
ifneq ($(WEB_SRCS),)
  WEB_OUT       = $(patsubst %, $(WEB_OUT_DIR)/%, $(WEB_SRCS))
  WEB_TARGET    = $(WEB_OUT)
endif

################################################################################
# If the makefile is not part of any component
################################################################################
ifdef NON_COMP # If it's a non component makefile, use current directories
  OBJ_DIR           = .
  OUT_DIR           = .
endif


################################################################################
# Stuff to link in if there is a fortran-c combo
################################################################################
ifneq ($(FOR_SRCS),)
  ifneq ($(C_SRCS),)
    FC_FORLIB_DIR  := $(GS_FC_FORLIB_DIR)
    FC_CLIB_DIR    := $(GS_FC_CLIB_DIR)
    FC_LIBS        := -lF77 -lV77 -lM77 -lsunmath
    FC_LFLAGS      := -L$(FC_FORLIB_DIR) -L$(FC_CLIB_DIR)
    F_LDFLAGS      :=
    SYS_LIBS       += -lm
  else
    FC_LFLAGS      :=
    F_LDFLAGS      :=
  endif
endif


################################################################################
# Flags that will be used by the compiler and linker.  These flags are component
# specifications for the compiler and linker.  Flag specifications for other
# packages will be found in Makedefs.xxx where xxx is a commercial package
# identifier.  The values will likely be modified to meet component needs but,
# the variable names should remain the same to work in conjunction with genmake.
#
# AUTOCONF NOTE:  These are things that autoconf will need to be aware of.
#   See Autoconf manual by Mackenzie, Elliston, Demaille
#      Chapter 4:  Initialization and Output Files (p21)
################################################################################
ARCHIVER            = $(AR)
C_COMPILER         := $(CC)
CXX_COMPILER       := $(CXX)
FOR_COMPILER       := $(FC)
PERL_COMPILER      := $(PERL_PATH)
PYTHON_COMPILER    := python
PHP_COMPILER       := php
JAVA_COMPILER      := javac

ifneq ($(FOR_SRCS),)
    LINKER          = $(FC)
else
  ifneq ($(CXX_SRCS),)
    LINKER         := $(CXX)
  else
    LINKER         := $(CC)
    C_SO_FLAGS      = -K pic
  endif
endif

DEF_IFLAGS          = -I$(INC_DIR) -I.
DEF_LFLAGS          = -L$(LIB_DIR)

LIBS    = $(AUX_LIBS) $(COMP_LIBS) $(EXTERNAL_LIBS) $(FC_LIBS) $(SYS_LIBS)
DFLAGS  = $(AUX_DFLAGS) $(COMP_DFLAGS) $(EXTERNAL_DFLAGS)
CFLAGS  = $(AUX_CFLAGS) $(COMP_CFLAGS) $(EXTERNAL_CFLAGS)
IFLAGS  = $(DEF_IFLAGS) $(AUX_IFLAGS) $(COMP_IFLAGS) $(EXTERNAL_IFLAGS)
LFLAGS  = $(DEF_LFLAGS) $(AUX_LFLAGS) $(COMP_LFLAGS) $(EXTERNAL_LFLAGS) $(FC_LFLAGS)
LDFLAGS = $(AUX_LDFLAGS) $(COMP_LDFLAGS) $(EXTERNAL_LDFLAGS) $(F_LDFLAGS)

ifdef SO
  ifeq ($(OS_NAME),SunOS)
    SO_FLAGS        = -G $(C_SO_FLAGS)
  else
    SO_FLAGS        = -shared -fPIC
  endif
endif

OPTIMIZE_TAG        = -g
CD_FLAGS            = $(OPTIMIZE_TAG) $(DFLAGS) $(CFLAGS)
C_COMPILE_FLAGS     = $(strip $(CD_FLAGS) $(IFLAGS) $(BITS64_FLAGS) $(SO_FLAGS))
CXX_COMPILE_FLAGS   = $(strip $(CD_FLAGS) $(IFLAGS) $(BITS64_FLAGS) $(SO_FLAGS))
FOR_COMPILE_FLAGS   = $(strip $(CD_FLAGS) $(IFLAGS) $(BITS64_FLAGS))
PERL_COMPILE_FLAGS  = -I$(LIB_DIR) -c
PHP_COMPILE_FLAGS   = -l
JAVA_COMPILE_FLAGS  = $(CD_FLAGS) -d $(JAVA_COMPILE_DIR)
LINKER_FLAGS        = $(OPTIMIZE_TAG) $(SO_FLAGS) $(BITS64_FLAGS) $(DFLAGS) $(LFLAGS) $(LDFLAGS)

################################################################################
# VPATH allows searching directories for dependencies.  We may be able to
# improve performance by replacing VPATH with specific vpath specifications.
# This hasn't actually been tested.
#
# We should remove . from the .Hh path if we can get people to
# voluntarily conform to the header file directory structure.
################################################################################
vpath %.H         .:$(INC_DIR)
vpath %.h         .:$(INC_DIR)
vpath %.class     .:$(JAVA_OUT_DIR)
vpath %.o         .:$(OBJ_DIR)
vpath %.a         $(LIB_DIR)
vpath Makedefs.%  $(DEF_MF_DIR):$(CUST_MF_DIR)
vpath Makerules.% $(DEF_MF_DIR):$(CUST_MF_DIR)

################################################################################
# A few miscellaneous things still to do
################################################################################
SRCS       = $(strip $(REG_SRCS) $(PYTHON_SRCS) $(PERL_SRCS) $(PHP_SRCS) $(JAVA_SRCS) $(IDL_SRCS) $(MATLAB_SRCS) $(CSH_SRCS) $(BASH_SRCS) $(SH_SRCS) $(KSH_SRCS) $(WEB_SRCS) $(OTHER_SRCS))
OUT        = $(REG_OUT) $(SO_OUT) $(SWIG_OUT) $(PYTHON_OUT) $(PERL_OUT) $(PHP_OUT) $(JAVA_OUT) $(IDL_OUT) $(MATLAB_OUT) $(CSH_OUT) $(BASH_OUT) $(SH_OUT) $(KSH_OUT) $(WEB_OUT) $(OTHER_OUT)
THE_TARGET = $(REG_TARGET) $(SO_TARGET) $(SWIG_TARGET) $(PYTHON_TARGET) $(PERL_TARGET) $(PHP_TARGET) $(JAVA_TARGET) $(IDL_TARGET) $(MATLAB_TARGET) $(CSH_TARGET) $(BASH_TARGET) $(SH_TARGET) $(KSH_TARGET) $(WEB_TARGET) $(OTHER_TARGET)

DEP_OUT_OLD= $(patsubst %, -o%, $(OUT))
DEP_OUT    = $(patsubst %, -rego %, $(REG_OUT))
DEP_OUT   += $(patsubst %, -soo %, $(SO_OUT))
DEP_OUT   += $(patsubst %, -javao %, $(JAVA_OUT))
#DEP_OUT   += $(patsubst %, -perlo %, $(PERL_OUT))
#DEP_OUT   += $(patsubst %, -phpo %, $(PHP_OUT))
#DEP_OUT   += $(patsubst %, -idlo %, $(IDL_OUT))
#DEP_OUT   += $(patsubst %, -csho %, $(CSH_OUT))
#DEP_OUT   += $(patsubst %, -sho %, $(SH_OUT))
#DEP_OUT   += $(patsubst %, -basho %, $(BASH_OUT))
#DEP_OUT   += $(patsubst %, -ksho %, $(KSH_OUT))

COMP_PKG     = -comp $(COMP_NAME) -pkg $(PKG_NAME)
GENDEP_ARGS  = $(COMP_PKG) $(IFLAGS) $(LFLAGS) $(LIBS) $(SRCS) -parse

MF_LIST = -m $(MF)
ifneq ($(AUX_MF),)
  MF_LIST += -m $(AUX_MF)
endif


################################################################################
# Do some error checking and just set THE_TARGET to the error to bail
################################################################################
ERROR := MAKEFILE_ERROR

ifndef NEW_WAY
  ERR_MESG    = echo "    this is an old makefile, run genmake -redo";
endif

ifeq ($(OUT),)
  ERR_MESG   += echo "    no recognizable target";
endif

ifndef MAKE_TYPE
  ERR_MESG   += echo "    MAKE_TYPE undefined";
endif

ifeq ($(COMP_NAME),)
  ERR_MESG   += echo "    COMP_NAME undefined";
endif

ifeq ($(WEB_SFXS),$(FAIL_MESG))
  ERR_MESG   += echo "    WEB_SFXS undefined -- $(FAIL_MESG)";
endif

ifneq ($(PERL_SRCS),)
  ifeq ($(PERL_PATH),$(FAIL_MESG))
    ERR_MESG += echo "    PERL_PATH undefined -- $(FAIL_MESG)";
  endif
endif

#ifneq ($(PHP_SRCS),)
#  ifeq ($(PHP_PATH),$(FAIL_MESG))
#    ERR_MESG += echo "    PHP_PATH undefined -- $(FAIL_MESG)";
#  endif
#endif

ifneq ($(FOR_SRCS),)
  ifneq ($(C_SRCS),)
    ifeq ($(FC_FORLIB_DIR),$(FAIL_MESG))
      ERR_MESG += echo "    FC_FORLIB_DIR undefined -- $(FAIL_MESG)";
    endif
    ifeq ($(FC_CLIB_DIR),$(FAIL_MESG))
        ERR_MESG += echo "    FC_CLIB_DIR undefined -- $(FAIL_MESG)";
    endif
  endif
endif

ifeq ($(strip $(SRCS)),)
  ifneq ($(MAKE_TYPE),misc)
    ifneq ($(MAKE_TYPE),content)
      ERR_MESG += echo "    no source files exist";
    endif
  endif
endif

#  OBJ_DIR          := $(ERROR)
ifneq ($(ERR_MESG),)
  RM               := @echo
  RM_RECURSE       := @echo
  SRCS             := $(ERROR)
  OBJS             := $(ERROR)
  OBJ_DEPS         := $(ERROR)
  OBJ_FILES        := $(ERROR)
  OUT              := $(ERROR)
  PERL_OUT         := $(ERROR)
  PYTHON_OUT       := $(ERROR)
  OUT_DIR          := $(ERROR)
  JAVA_OUT_DIR     := $(ERROR)
  JAVA_WEB_OUT_DIR := $(ERROR)
  PERL_OUT_DIR     := $(ERROR)
  PYTHON_OUT_DIR   := $(ERROR)
  PHP_OUT_DIR      := $(ERROR)
  CSH_OUT_DIR      := $(ERROR)
  BASH_OUT_DIR     := $(ERROR)
  SH_OUT_DIR       := $(ERROR)
  KSH_OUT_DIR      := $(ERROR)
  THE_TARGET       := $(ERROR)
  RELEASE_TARGET   := $(ERROR)
  DEFAULT_TARGET   := $(ERROR)
  COMP_NAME        := $(ERROR)
  COMPONENT        := $(ERROR)
  COMP_HOME        := $(ERROR)
  COMP_CLEAN       := $(ERROR)
  AUX_CLEAN        := $(ERROR)
  BIN_DIR          := $(ERROR) # To catch old makefile stuff appropriately
  LIB_DIR          := $(ERROR) # To catch old makefile stuff appropriately
  BIN              := $(ERROR) # To catch old makefile stuff appropriately
  LIB              := $(ERROR) # To catch old makefile stuff appropriately
  THING_TO_MAKE    := $(ERROR) # To catch old makefile stuff appropriately
endif


################################################################################
# Platform specific definitions.  This will be quite component dependent.  The
# idea here is to use the ifeq construct provided by GNU make to set variables'
# values based on the platform.
################################################################################



PLATFORM = platform variable is defined and apparanetly used
