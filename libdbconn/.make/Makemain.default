################################################################################
# RCS INFORMATION: 
#   $Author: younkin $ 
#   $Locker:  $ 
#   $Revision: 1.30 $ 
#   $Date: 2008-06-13 17:19:50 $ 
#   $Name: not supported by cvs2svn $ 
#   $State: Exp $ 
#
# PURPOSE:
#   To determine the needed make templates and include them in the right order.
#
# DESCRIPTION:
#   This makefile sets some simplistic and widely used variables, determines if
#   the component is the IAM component, and then finds and includes all the
#   needed makefile templates.
#
#   This is done by making use of the variables set by the file called
#   "Makefile" that was generated by genmake.  This is the procedure:
#
#      1.  A developer runs genmake with the needed options
#      2.  A makefile is generated containing configuration based on the options
#      3.  The main template (this file) is included by the generated makefile
#      4.  The configuration in the generated file is used to do the following:
#           a)  Determine what templates neede to be included
#           b)  Set variables for target names and paths
#           c)  Satisfy the building of the targets
#
#   This is done in a structured manner so that the right targets are invoked
#   in the right order.
#
#------------------------------------------------------------------------
#
# NOTE:  Use $(warning) in any assignment to print a warning that will not
#        affect the value of the assignment.  For example:
#                DUMMY = $(warning this is a warning)dummy
#        This will assign 'dummy' to the variable DUMMY and print
#                'this is a warning'
#        to STDERR.
#
#
# Interesting info taken from "GNU Make" by Stallman and McGrath.
#
#   These are the Automatic variables used in gnumake (p112):
#
#   $@ - file name of the target of the rule
#   $% - target member name if archive (eg $% = bar.o given foo.a(bar.o))
#   $< - name of the first dependency
#   $^ - names of all dependencies (with spaces)
#   $? - names of all dependencies newer than the target (with spaces)
#   $* - stem of target in implicit rule match (eg $* = x given a.x.b and a.%.b)
#
#   Some useful variables with built-in values (p107-108, unuseful excluded)
#
#   AR = ar           (archive maintaining program -- we will use this)
#   ARFLAGS = rv      (flags for ar -- we will use/suppliment this)
#   CC = cc           (C compiler -- we will use this)
#   FC = f77          (Fortran compiler -- we may use this)
#   CPP = $(CC) -E    (C preprocessor -- we may use this)
#   CXX = g++         (C++ compiler -- we define CC instead)
#   CO = co           (Extracting files from RCS -- we will use this)
#   RM = rm -f        (Command to remove a file -- we will use this I guess)
#
# LIMITATIONS:
################################################################################


NEW_WAY        := true
OLD_COMP_MESG  := WARNING:  Old component variable name:  COMPONENT, use genmake -redo


################################################################################
# Some important variables used all over the place
################################################################################
SHELL          := /bin/sh
PWD            := $(shell pwd)
OS_NAME        := $(shell uname -s)
ARCH_NAME      := $(shell uname -m)
SPACE          := $(EMPTY) $(EMPTY)
COMMA          := ,
FAIL_MESG      := failed shell call
STD_ERR        := 2> /dev/null
STD_OUT        := > /dev/null
STD_ALL        := > /dev/null 2>&1
FAIL           := $(STD_ERR) || echo $(FAIL_MESG)

ifdef WARN
  BIT_BUCKET   := "WARNING:  $(WARN)"; echo "target: $@"
else
  BIT_BUCKET   := '' $(STD_OUT)
endif

################################################################################
# Establish and include the makefile with the IAM setup configuration (gs)
################################################################################
MAKE_SUB_DIR   := .make
GS_MF          := $(MAKE_SUB_DIR)/Makedefs.gs

include $(GS_MF)


################################################################################
# Establish IAM properties
################################################################################
IAM            := $(GS_IAM)
IAM_IC         := $(IAM)
IAM_LC         := $(shell echo $(IAM) | tr "[:upper:]" "[:lower:]")
IAM_UC         := $(shell echo $(IAM) | tr "[:lower:]" "[:upper:]")
IAM_HOME       := $(GS_IAM_HOME)

# This is for SWAWT 4 backwards compatibility.  The GNU autotools have reserved
# "PACKAGE" as a make variable for their use.  Therefore "PACKAGE" was changed
# to "PKG_NAME" and "COMPONENT" was changed to "COMP_NAME."
ifndef COMP_NAME
  ifdef COMPONENT
    COMP_NAME := $(warning $(OLD_COMP_MESG))$(COMPONENT)
  else
    ifdef IAM_DEVELOPER
      COMP_NAME  := $(IAM_LC)
    endif
  endif
endif

ifeq ($(COMP_NAME),)
  COMP_NAME    := $(notdir $(COMP_HOME))
else
  UC_COMP      := $(shell echo $(COMP_NAME) | tr "[:lower:]" "[:upper:]")
  COMP_HOME    := $($(UC_COMP)_HOME)
endif

ifeq ($(COMP_NAME),)
  ERR_MESG     += echo "    Can't get component name from makefile -- $(FAIL_MESG)"
endif

PKG_NAME := $(shell pwd|sed -e "s:$(COMP_HOME)/src/::" | awk -F/ '{print $$1}')


################################################################################
# Establish the location of all the templates and see if they exist
################################################################################

DEF_MF_DIR     := $(MAKE_SUB_DIR)
CUST_MF_DIR    := $(MAKE_SUB_DIR)

CLIENT         := $(GS_CLIENT_ABBR)

CLIENT_DEFS_MF  = $(shell ls $(CUST_MF_DIR)/Makedefs.$(CLIENT) $(STD_ERR))
CLIENT_RULES_MF = $(shell ls $(CUST_MF_DIR)/Makerules.$(CLIENT) $(STD_ERR))

MF              = Makefile
AUX_MF         := $(shell ls Makefile.aux $(STD_ERR))
DEPENDENCY_MF   = $(MAKE_SUB_DIR)/Makefile.deps
EXTERNAL_MF     = Makefile.ext
IDL_MF          = $(shell ls $(CUST_MF_DIR)/Makedefs.idl $(STD_ERR))
MATLAB_MF       = $(shell ls $(CUST_MF_DIR)/Makedefs.matlab $(STD_ERR))

ifeq ($(COMP_NAME),example)
  COMP_DEFS_MF  = $(shell ls $(DEF_MF_DIR)/Makedefs.$(COMP_NAME) $(STD_ERR))
  COMP_RULES_MF = $(shell ls $(DEF_MF_DIR)/Makerules.$(COMP_NAME) $(STD_ERR))
else
  COMP_DEFS_MF  = $(shell ls $(CUST_MF_DIR)/Makedefs.$(COMP_NAME) $(STD_ERR))
  COMP_RULES_MF = $(shell ls $(CUST_MF_DIR)/Makerules.$(COMP_NAME) $(STD_ERR))
endif


################################################################################
# DEFINITION FILES
#
# Inlcude all the "definitions" makefile templates.  These will contain only
# GNU Make variable definitions, there will be no targets or rules.
################################################################################
include $(DEF_MF_DIR)/Makedefs.default

# Now override anything with a client def file if it exists
ifneq ($(CLIENT_DEFS_MF),)
  include $(CLIENT_DEFS_MF)
endif

ifneq ($(COMP_DEFS_MF),)
  include $(COMP_DEFS_MF)
endif


################################################################################
# FIRST RULE
#
# This is the very first rule, before any rules in the actual Makefile, and
# before any rule in any included Makefile,.
#
# This is very important because we need to define what happens when a user
# says make with no targets on the command line.  The reason we need this
# control is because it needs to have something reasonable to do when nothing
# is specified.  At the same time, the default action can be defined in the
# auxiliary makefile if it exists.
#
# So, the first_rule is used to say "make the default rule if nothing is
# specified on the command line."  Now, the default rule will build whatever is
# in the DEFAULT_TARGET variable, which is defined in Makedefs.default to be
# 'all' but can be overridden in an auxiliary makefile to be anything.
#
# The first_rule must come before the auxiliary makefile is included because
# there may be rules in the optional auxiliary makefile and if first_rule wasn't
# here, then make would take the first rule in the auxiliary file, which
# wouldn't be good.
#
# The default rule (using the DEFAULT_TARGET variable) must come after the
# auxiliary file is included so that the variable, DEFAULT_TARGET can be
# overridden in the auxiliary file and then used in the default rule.
#
# So, given all of this, first_rule is defined, followed by the optional
# inclusion of an auxliary makefile, followed by the default target which may
# or may not be specified in the auxiliary makefile.
################################################################################
first_rule:  default
	@echo $(BIT_BUCKET)


################################################################################
# DEPENDENCIES AND AUXILIARY OVERRIDES
#
# The dependency file defines OLD_SRCS, and SRCS may be overridden in an
# auxiliary makefile, therefore, if these two files exist, they must be
# included.  After that, check to see that OLD_SRCS is defined in the
# dependency file.  If OLD_SRCS isn't set then the dependency file didn't exist
# or is from a previous version.  If OLD_SRCS isn't equal to SRCS, then new
# source code files have been added, making the dependency file out of date.
# In either case, we need to regenerate the dependency file using the
# 'depend_and_rebuild' target.  The reason for regenerating is also specified.
# If OLD_SRCS is equal to SRCS, then the dependency file is up to date and we
# do not regenerate it.
################################################################################
# The dependency file
ifneq ($(shell ls $(DEPENDENCY_MF) $(STD_ERR)),)
  include $(DEPENDENCY_MF)
endif

# Auxiliary makefile if it exists
ifneq ($(AUX_MF),)
  include $(AUX_MF)
endif

# Check this here because we want the IAM_UC OPTIMIZE environment variable to
# override anything else.  However, if it is not set, then we want to override
# using the appropriate hierarchy as defined in this file.
ifdef $(IAM_UC)_OPTIMIZE_TAG
  OPTIMIZE_TAG = $($(IAM_UC)_OPTIMIZE_TAG)
endif

ifndef OLD_SRCS
# CRY : find out why this was here
#  ifneq ($(COMP_NAME),$(IAM_LC))
    DEPEND   = depend_and_rebuild
    REASON   = it didn't exist
#  endif
else
  ifneq ($(OLD_SRCS),$(SRCS))
    DEPEND = depend_and_rebuild
    REASON = sources changed
    OS := $(OLD_SRCS)
    S  := $(SRCS)
    ifeq ($(S),$(OS))
      EQUAL = yep
    else
      EQUAL = nope
    endif
  else
    REASON = depend was the given target
  endif
endif


################################################################################
# RULES FILES
#
# Inlcude all the "rules" makefile templates.  These will contain only rules,
# there will be no variable definitions.  Any rules found in these files,
# including the dependency file, will come after the "first rule" defined above.
# That guarantees the the first rule is known.
################################################################################

# IDL makefile if it exists
ifneq ($(IDL_MF),)
  include $(IDL_MF)
endif

# Matlab makefile if it exists
ifneq ($(MATLAB_MF),)
  include $(MATLAB_MF)
endif

# External makefiles if they exist
ifneq ($(EXTERNALS),)
  include $(EXTERNAL_MF)
endif

# Rules makefile
include $(DEF_MF_DIR)/Makerules.default

# Now override anything with a client rule file if it exists
ifneq ($(CLIENT_RULES_MF),)
  include $(CLIENT_RULES_MF)
endif

# Component level rules file if it exists
ifneq ($(COMP_RULES_MF),)
  include $(COMP_RULES_MF)
endif
